"""
Script that helps to create the makefile and header file for
compiling the Brownian motion code.

This refactored version resides in python_tools/ and operates on the
source files located in ../src/.
"""

from pathlib import Path
import subprocess
from typing import List


# -----------------------------
# Path Configuration
# -----------------------------

# directory of this script
SCRIPT_DIR = Path(__file__).resolve().parent

# directory containing C source files and the makefile
SRC_DIR = SCRIPT_DIR.parent / "src"


# -----------------------------
# I/O Utilities
# -----------------------------

def print_list_index(items: List[str], message: str) -> None:
    print(message)
    print("ind\tname")
    for idx, name in enumerate(items):
        print(f"{idx}:\t{name}")
    print()


def scan_input(message: str) -> str:
    return input(message)


def get_selected_file(selection: str, options: List[str]) -> List[str]:
    """Match exact, index or partial filename."""
    if not selection:
        return []

    # Exact match
    if selection in options:
        return [selection]

    # Index
    if selection.isdigit():
        idx = int(selection)
        if 0 <= idx < len(options):
            return [options[idx]]

    # Partial match
    partial = [f for f in options if selection in f]
    return partial


def select_file(options: List[str], message: str) -> str:
    """Return a single selected module filename."""
    selection = scan_input(message)
    matches = get_selected_file(selection, options)

    if not matches:
        raise ValueError(f"No matching files found for '{selection}'")

    return matches[0]


# -----------------------------
# File discovery
# -----------------------------

def get_module_files(prefix: str, message: str) -> List[str]:
    """Return all *.c files starting with a prefix inside src/."""
    files = [f.name for f in SRC_DIR.glob(f"{prefix}*.c")]
    print_list_index(files, message)
    return files


# -----------------------------
# Compiler selection
# -----------------------------

def check_for_mpicc() -> bool:
    """Return True if mpicc exists."""
    result = subprocess.run(["which", "mpicc"], capture_output=True, text=True)
    return result.stdout.strip() != ""


def get_compiler(mpicc_available: bool) -> str:
    compilers = ['gcc', 'clang', 'icc']
    if mpicc_available:
        compilers.append('mpicc')

    print_list_index(compilers, "\nSuggested compilers:")
    selection = scan_input("\nChoose compiler (index or name, empty = manual): ")

    if selection:
        matches = get_selected_file(selection, compilers)
        if matches:
            return matches[0]

    return scan_input("Type the compiler name: ")


# -----------------------------
# Makefile manipulation
# -----------------------------

def adapt_line(line: str, new_value: str) -> str:
    left = line.split("=", 1)[0].strip()
    return f"{left} = {new_value}\n"


def adapt_makefile(compiler: str, conf: str, inter: str) -> None:
    makefile = SRC_DIR / "makefile"

    if not makefile.exists():
        raise FileNotFoundError(f"{makefile} not found.")

    lines_out = []
    for line in makefile.read_text().splitlines(keepends=True):
        if line.startswith("CC"):
            lines_out.append(adapt_line(line, compiler))
        elif line.startswith("CONF"):
            lines_out.append(adapt_line(line, conf))
        elif line.startswith("INT"):
            lines_out.append(adapt_line(line, inter))
        else:
            lines_out.append(line)

    tmp = makefile.with_suffix(".tmp")
    tmp.write_text("".join(lines_out))
    tmp.replace(makefile)  # atomic replace


# -----------------------------
# Header generation
# -----------------------------

def write_conf_int_header(conf_c: str, int_c: str, compiler: str) -> None:
    conf_h = Path(conf_c).with_suffix(".h").name
    int_h = Path(int_c).with_suffix(".h").name

    header = SRC_DIR / "comp_gen_header.h"

    lines = [
        "/**\n",
        " * Auto-generated wrapper header for confinement and interaction modules.\n",
        " * Sets MPI_ON if mpicc is used.\n",
        f" * Generated by {__file__}\n",
        " */\n\n",
        f'#include "{int_h}"\n',
        f'#include "{conf_h}"\n',
    ]

    if compiler == "mpicc":
        lines.append('#include "mpi.h"\n')
        lines.append('#define MPI_ON\n')

    header.write_text("".join(lines))


# -----------------------------
# Make invocation
# -----------------------------

def run_make() -> None:
    subprocess.run(["make"], cwd=SRC_DIR, check=True)


# -----------------------------
# Main control flow
# -----------------------------

def main():
    print(f"Working inside: {SRC_DIR}\n")

    # Confinement
    conf_files = get_module_files("conf", "\nAvailable confinement modules:")
    conf_choice = select_file(conf_files, "Choose confinement module: ")

    # Interaction
    int_files = get_module_files("int", "\nAvailable interaction modules:")
    int_choice = select_file(int_files, "Choose interaction module: ")

    # Compiler
    compiler = get_compiler(check_for_mpicc())

    # Modify makefile
    adapt_makefile(compiler, conf_choice, int_choice)

    # Generate header
    write_conf_int_header(conf_choice, int_choice, compiler)

    # Run make inside src/
    run_make()


if __name__ == "__main__":
    main()

